classdef dat_class < handle 
  %% DAT_CLASS Add summary here
  % Public, tunable properties
  properties
    %% data config (constant)
    datDir              = [pwd '/data/']; % data dir     
    st_frame          = 1; % start frame index
    end_frame       = nan;% end frame index
    benchtype       = 'KITTI'; % default
    seq                   = 3; % aux config, used in KITTI     

    % data config dependent (constant)
    dataset;
    posp
    skipFrame       = 0; % num of frames skipped bwt two keyframes        
    numImag % total num of images
    keyFrames;
    numKeyFrames % num of keyframes

  end
  
  properties(Nontunable)% Public, non-tunable properties
  end
  properties(DiscreteState)
  end
  properties(Access = private) % Pre-computed constants
  end

  methods
    % Constructor
    function obj = dat_class(varargin)
      setProperties(obj,nargin,varargin{:}) % init obj w name-value args
    end 
    function obj = dat_init(datDir, benchtype, benchnum, st_frame, end_frame)

      obj.datDir  =   datDir  ;
      obj.benchtype  =  benchtype  ;
      obj.benchnum  =  benchnum  ;
      obj.st_frame =  st_frame ;
      obj.end_frame =  end_frame ;
      
      %init 
      [obj.dataset, obj.posp] = LoadDataset(datDir, benchtype, benchnum, st_frame, end_frame); 

      if strcmp(obj.benchtype,'KITTI')
        obj.skipFrame = 1; 
      elseif strcmp(obj.benchtype,'NAIST')
        obj.skipFrame = 1; 
      elseif strcmp(obj.benchtype,'ICL')
        obj.skipFrame = 1; 
      elseif strcmp(obj.benchtype,'TUM')
        obj.skipFrame = 1;     
      end
 
      obj.numImag              = length(obj.dataset.fnames); 
      obj.keyFrames           = 2+obj.skipFrame:1+obj.skipFrame:obj.numImag; 
      obj.numKeyFrames   = length(obj.keyFrames); 
    end
  end

  methods(Access = protected)
    %% Common functions
    function setupImpl(obj)
      % Perform one-time calculations, such as computing constants
    end

    function y = stepImpl(obj,u)
      % Implement algorithm. Calculate y as a function of input u and
      % discrete states.
      y = u;
    end

    function resetImpl(obj)
      % Initialize / reset discrete-state properties
    end

    %% Backup/restore functions
    function s = saveObjectImpl(obj)
      % Set properties in structure s to values in object obj

      % Set public properties and states
      s = saveObjectImpl@matlab.System(obj);

      % Set private and protected properties
      %s.myproperty = obj.myproperty;
    end

    function loadObjectImpl(obj,s,wasLocked)
      % Set properties in object obj to values in structure s

      % Set private and protected properties
      % obj.myproperty = s.myproperty; 

      % Set public properties and states
      loadObjectImpl@matlab.System(obj,s,wasLocked);
    end

    %% Advanced functions
    function validateInputsImpl(obj,u)
      % Validate inputs to the step method at initialization
    end

    function validatePropertiesImpl(obj)
      % Validate related or interdependent property values
    end

    function ds = getDiscreteStateImpl(obj)
      % Return structure of properties with DiscreteState attribute
      ds = struct([]);
    end

    function processTunedPropertiesImpl(obj)
      % Perform actions when tunable properties change
      % between calls to the System object
    end

    function flag = isInputSizeMutableImpl(obj,index)
      % Return false if input size cannot change
      % between calls to the System object
      flag = false;
    end

    function flag = isInactivePropertyImpl(obj,prop)
      % Return false if property is visible based on object 
      % configuration, for the command line and System block dialog
      flag = false;
    end
  end
end
