function [outputArg1,outputArg2] = qekf(dset, ...
                              dim_x, ...
                              dim_z, ...
                              dim_u, ...
                              T_, ...
                              Q_T_xyz, ...
                              Q_V_xyz, ...
                              Q_quat_xyz, ...
                              R_noise, ...
                              P_est_0, ...
                              IC)
%QEKF Summary of this function goes here
%   Detailed explanation goes here
addpath(genpath('qekf_utils'));
qekf_obj = qekf_class(dim_x, ...
                      dim_z, ...
                      dim_u, ...
                      T_, ...
                      Q_T_xyz, ...
                      Q_V_xyz, ...
                      Q_quat_xyz, ...
                      R_noise, ...
                      P_est_0, ...
                      IC);

x_TVQxyz = qekf_obj.x_TVQxyz; % init state vec

for i in range(dset.start, dset.end):
    ''' EKF state machine '''
    # print('    \\--->>> new state ------->>>>>:  ', i)
    u_Wrpy = dset.u_Wrpy_np[i].reshape(-1,1)
    z_TVQxyz = dset.z_TVQxyzw_np[i,:-1].reshape(-1,1)
    z_TVQxyzw = dset.z_TVQxyzw_np[i].reshape(-1,1) # only for data logging
    # nsprint('x_TVQxyz', x_TVQxyz)
    # nsprint('u_Wrpy', u_Wrpy)
    # nsprint('z_TVQxyz', z_TVQxyz)
    # st()
    x_TVQxyz = qekf.predict(x_TVQxyz, u_Wrpy)
    # nsprint('x_TVQxyz', x_TVQxyz)
    x_TVQxyz = qekf.update(x_TVQxyz, z_TVQxyz)
    # st()
    ''' log z state vector '''
    qekf.log.log_z_state(z_TVQxyzw, i)
  print('end of qekf data iterator ----->>')
   
end

